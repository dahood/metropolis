// Generated by CoffeeScript 1.10.0

/*
This program is distributed under the terms of the MIT license.
Copyright 2012 - 2015 (c) Markus Kohlhase <mail@markus-kohlhase.de>
 */

(function() {
  var countComments, countMixed, emptyLines, emptyLns, endOfLine, extensions, getCommentExpressions, getStopRegex, getType, indexOfGroup, keys, lineSum, matchDefinedGroup, matchIdx, newLines, newLns, nonEmpty, slocModule, trampoline,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  keys = ['total', 'source', 'comment', 'single', 'block', 'mixed', 'empty'];

  nonEmpty = /[^\s]/;

  endOfLine = /$/m;

  newLines = /\n/g;

  emptyLines = /^\s*$/mg;

  getCommentExpressions = function(lang) {
    var r, single, start, stop;
    single = (function() {
      switch (lang) {
        case "coffee":
        case "iced":
        case "cr":
        case "py":
        case "ls":
        case "mochi":
        case "nix":
        case "r":
        case "rb":
        case "jl":
        case "pl":
        case "yaml":
        case "hr":
          return /\#/;
        case "js":
        case "jsx":
        case "c":
        case "cc":
        case "cpp":
        case "cs":
        case "cxx":
        case "h":
        case "m":
        case "mm":
        case "hpp":
        case "hx":
        case "hxx":
        case "ino":
        case "java":
        case "php":
        case "php5":
        case "go":
        case "groovy":
        case "scss":
        case "less":
        case "rs":
        case "sass":
        case "styl":
        case "scala":
        case "swift":
        case "ts":
        case "jade":
        case "gs":
          return /\/{2}/;
        case "lua":
        case "hs":
          return /--/;
        case "erl":
          return /\%/;
        case "monkey":
        case "vb":
          return /'/;
        case "nim":
          r = /(?:^[^\#]*)(\#)(?:(?![\#\!]))/;
          r._matchGroup_ = 1;
          return r;
        case "rkt":
        case "clj":
        case "cljs":
        case "hy":
        case "asm":
          return /;/;
        default:
          return null;
      }
    })();
    switch (lang) {
      case "coffee":
      case "iced":
        start = stop = /\#{3}/;
        break;
      case "js":
      case "jsx":
      case "c":
      case "cc":
      case "cpp":
      case "cs":
      case "cxx":
      case "h":
      case "m":
      case "mm":
      case "hpp":
      case "hx":
      case "hxx":
      case "ino":
      case "java":
      case "ls":
      case "nix":
      case "php":
      case "php5":
      case "go":
      case "css":
      case "sass":
      case "scss":
      case "less":
      case "rs":
      case "styl":
      case "scala":
      case "ts":
      case "gs":
      case "groovy":
        start = /\/\*+/;
        stop = /\*\/{1}/;
        break;
      case "python":
      case "py":
        start = stop = /\"{3}|\'{3}/;
        break;
      case "handlebars":
      case "hbs":
      case "mustache":
        start = /\{\{\!/;
        stop = /\}\}/;
        break;
      case "hs":
        start = /\{-/;
        stop = /-\}/;
        break;
      case "html":
      case "htm":
      case "svg":
      case "xml":
        start = /<\!--/;
        stop = /-->/;
        break;
      case "lua":
        start = /--\[{2}/;
        stop = /--\]{2}/;
        break;
      case "monkey":
        start = /#rem/i;
        stop = /#end/i;
        break;
      case "nim":
        start = /\#{2}/;
        break;
      case "rb":
        start = /\=begin/;
        stop = /\=end/;
        break;
      case "rkt":
        start = /#\|/;
        stop = /\|#/;
        break;
      case "jl":
        start = /\#\=/;
        stop = /\=\#/;
        break;
      case "ml":
      case "mli":
        start = /\(\*/;
        stop = /\*\)/;
        break;
      default:
        if (indexOf.call(extensions, lang) >= 0) {
          start = stop = null;
        } else {
          throw new TypeError("File extension '" + lang + "' is not supported");
        }
    }
    return {
      start: start,
      stop: stop,
      single: single
    };
  };

  countMixed = function(res, lines, idx, startIdx, match) {
    var ref;
    if ((nonEmpty.exec(lines[0])) && (((ref = res.last) != null ? ref.stop : void 0) === idx || startIdx === idx)) {
      res.mixed.push({
        start: idx,
        stop: idx
      });
    }
    if ((match != null) && nonEmpty.exec(lines.slice(-1)[0].substr(0, match.index))) {
      return res.mixed.push({
        start: startIdx,
        stop: startIdx
      });
    }
  };

  getStopRegex = function(type, regex) {
    switch (type) {
      case 'single':
        return endOfLine;
      case 'block':
        return regex || endOfLine;
    }
  };

  getType = function(single, start) {
    if (single && !start) {
      return 'single';
    } else if (start && !single) {
      return 'block';
    } else {
      if (start.index <= single.index) {
        return 'block';
      } else {
        return 'single';
      }
    }
  };

  matchIdx = function(m) {
    return m.index + m[0].length;
  };

  emptyLns = function(c) {
    var ref;
    return ((ref = c.match(emptyLines)) != null ? ref.length : void 0) || 0;
  };

  newLns = function(c) {
    var ref;
    return ((ref = c.match(newLines)) != null ? ref.length : void 0) || 0;
  };

  indexOfGroup = function(match, n) {
    var i, ix, j, ref;
    ix = match.index;
    for (i = j = 1, ref = n; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      ix += match[i].length;
    }
    return ix;
  };

  matchDefinedGroup = function(reg, code) {
    var g, res;
    res = reg != null ? reg.exec(code) : void 0;
    if ((res != null) && ((g = reg != null ? reg._matchGroup_ : void 0) != null)) {
      res.index = indexOfGroup(res, g);
      res[0] = res[g];
    }
    return res;
  };

  countComments = function(code, regex) {
    var myself;
    myself = function(res, code, idx) {
      var cStartIdx, comment, empty, len, lines, match, single, splitAt, start, startIdx, stop, type;
      if (code === '') {
        return res;
      }
      if (code[0] === '\n') {
        return function() {
          return myself(res, code.slice(1), ++idx);
        };
      }
      start = matchDefinedGroup(regex.start, code);
      single = matchDefinedGroup(regex.single, code);
      if (!(start || single)) {
        countMixed(res, code.split('\n'), idx);
        return res;
      }
      type = getType(single, start);
      match = (function() {
        switch (type) {
          case 'single':
            return single;
          case 'block':
            return start;
        }
      })();
      cStartIdx = matchIdx(match);
      comment = code.substring(cStartIdx);
      lines = code.substring(0, match.index).split('\n');
      startIdx = lines.length - 1 + idx;
      stop = matchDefinedGroup(getStopRegex(type, regex.stop), comment);
      if (!stop) {
        res.error = true;
        return res;
      }
      empty = emptyLns(code.substring(match.index, cStartIdx + matchIdx(stop)));
      comment = comment.substring(0, stop.index);
      len = newLns(comment);
      splitAt = cStartIdx + comment.length + stop[0].length;
      code = code.substring(splitAt);
      countMixed(res, lines, idx, startIdx, match);
      res.last = {
        start: startIdx,
        stop: startIdx + len,
        empty: empty
      };
      res[type].push(res.last);
      return function() {
        return myself(res, code, startIdx + len);
      };
    };
    return trampoline(myself({
      single: [],
      block: [],
      mixed: []
    }, code, 0));
  };

  trampoline = function(next) {
    while (typeof next === 'function') {
      next = next();
    }
    return next;
  };

  lineSum = function(comments) {
    var c, d, i, j, len1, ref, sum;
    sum = 0;
    for (i = j = 0, len1 = comments.length; j < len1; i = ++j) {
      c = comments[i];
      d = (c.stop - c.start) + 1;
      if (((ref = comments[i + 1]) != null ? ref.start : void 0) === c.stop) {
        d--;
      }
      sum += d;
    }
    return sum;
  };

  slocModule = function(code, lang, opt) {
    var b, bIdx, block, blockEmpty, comment, empty, j, k, len1, len2, mixed, ref, ref1, ref2, res, s, single, source, total, x;
    if (opt == null) {
      opt = {};
    }
    if (typeof code !== "string") {
      throw new TypeError("'code' has to be a string");
    }
    code = code.replace(/\r\n|\r/g, '\n');
    if (code.slice(-1) === '\n') {
      code = code.slice(0, -1);
    }
    total = (1 + newLns(code)) || 1;
    empty = emptyLns(code);
    res = countComments(code, getCommentExpressions(lang));
    single = lineSum(res.single);
    block = lineSum(res.block);
    mixed = lineSum(res.mixed);
    comment = block + single;
    bIdx = (function() {
      var j, len1, ref, results;
      ref = res.block;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        b = ref[j];
        results.push(b.stop);
      }
      return results;
    })();
    ref = res.single;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      s = ref[j];
      if (ref1 = s.start, indexOf.call(bIdx, ref1) >= 0) {
        comment--;
      }
    }
    blockEmpty = 0;
    ref2 = res.block;
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      x = ref2[k];
      blockEmpty += x.empty;
    }
    source = total - comment - empty + blockEmpty + mixed;
    if (opt.debug) {
      console.log(res);
    }
    return {
      total: total,
      source: source,
      comment: comment,
      single: single,
      block: block,
      mixed: mixed,
      empty: empty
    };
  };

  extensions = ["asm", "c", "cc", "clj", "cljs", "coffee", "cpp", "cr", "cs", "css", "cxx", "erl", "go", "groovy", "gs", "h", "handlebars", "hbs", "hpp", "hr", "hs", "html", "htm", "hx", "hxx", "hy", "iced", "ino", "jade", "java", "jl", "js", "jsx", "less", "lua", "ls", "ml", "mli", "mochi", "monkey", "mustache", "nix", "nim", "php", "php5", "pl", "py", "r", "rb", "rkt", "rs", "sass", "scala", "scss", "styl", "svg", "swift", "ts", "vb", "xml", "yaml", "m", "mm"];

  slocModule.extensions = extensions;

  slocModule.keys = keys;

  if ((typeof define !== "undefined" && define !== null ? define.amd : void 0) != null) {
    define(function() {
      return slocModule;
    });
  } else if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = slocModule;
  } else if (typeof window !== "undefined" && window !== null) {
    window.sloc = slocModule;
  }

}).call(this);
