// Generated by CoffeeScript 1.10.0

/*
This program is distributed under the terms of the MIT license.
Copyright 2012 - 2016 (c) Markus Kohlhase <mail@markus-kohlhase.de>
 */

(function() {
  var addResult, async, collect, colorRegex, exts, filterFiles, fmtOpts, fmts, fs, groupByExt, helpers, k, keyvalue, list, object, options, p, parseFile, path, pkg, print, programm, readDir, readSingleFile, readdirp, result, sloc;

  fs = require('fs');

  path = require('path');

  async = require('async');

  programm = require('commander');

  readdirp = require('readdirp');

  sloc = require('./sloc');

  helpers = require('./helpers');

  pkg = require('../package.json');

  fmts = require('./formatters');

  list = function(val) {
    return val.split(',');
  };

  keyvalue = function(val) {
    return val.split('=');
  };

  object = function(val) {
    var custom, i, len, original, ref, result, split;
    result = {};
    ref = list(val).map(keyvalue);
    for (i = 0, len = ref.length; i < len; i++) {
      split = ref[i];
      custom = split[0], original = split[1];
      result[custom] = original;
    }
    return result;
  };

  exts = (function() {
    var i, len, ref, results;
    ref = sloc.extensions;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      results.push("*." + k);
    }
    return results;
  })();

  collect = function(val, memo) {
    memo.push(val);
    return memo;
  };

  colorRegex = /\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]/g;

  parseFile = function(f, cb) {
    var res;
    if (cb == null) {
      cb = function() {};
    }
    res = {
      path: f,
      stats: {},
      badFile: false
    };
    return fs.readFile(f, "utf8", function(err, code) {
      var ext;
      if (err) {
        res.badFile = true;
        return cb(err, res);
      }
      ext = path.extname(f).slice(1);
      res.stats = sloc(code, options.alias[ext] || ext);
      return cb(null, res);
    });
  };

  print = function(err, result, opts, fmtOpts) {
    var f, fmt, out;
    if (err) {
      return console.error("Error: " + err);
    }
    f = programm.format || 'simple';
    if ((fmt = fmts[f]) == null) {
      return console.error("Error: format " + f + " is not supported");
    }
    out = fmt(result, opts, fmtOpts);
    if (programm.stripColors) {
      out = out.replace(colorRegex, '');
    }
    if (typeof out === "string") {
      return console.log(out);
    }
  };

  addResult = function(res, all) {
    if (res.badFile) {
      all.brokenFiles++;
    }
    return all.files.push(res);
  };

  filterFiles = function(files) {
    var exclude, i, len, r, res, results;
    res = programm.exclude ? (exclude = new RegExp(programm.exclude), files.filter(function(x) {
      return !exclude.test(x.path);
    })) : files;
    results = [];
    for (i = 0, len = res.length; i < len; i++) {
      r = res[i];
      results.push(path.join(p, r.path));
    }
    return results;
  };

  options = {};

  fmtOpts = [];

  programm.version(pkg.version).usage('[option] <file> | <directory>').option('-e, --exclude <regex>', 'regular expression to exclude files and folders').option('-f, --format <format>', 'format output:' + ((function() {
    var results;
    results = [];
    for (k in fmts) {
      results.push(" " + k);
    }
    return results;
  })()).join(',')).option('--format-option [value]', 'add formatter option', collect, fmtOpts).option('--strip-colors', 'remove all color characters').option('-k, --keys <keys>', 'report only numbers of the given keys', list).option('-d, --details', 'report stats of each analyzed file').option('-a, --alias <custom ext>=<standard ext>', 'alias custom ext to act like standard ext', object);

  programm.parse(process.argv);

  options.keys = programm.keys;

  options.details = programm.details;

  options.alias = programm.alias;

  for (k in options.alias) {
    exts.push("*." + k);
  }

  if (programm.args.length < 1) {
    return programm.help();
  }

  result = {
    files: []
  };

  groupByExt = function(data) {
    var d, ext, f, i, len, m, map, ref;
    map = {};
    ref = data.files;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      ext = (path.extname(f.path)).slice(1);
      m = map[ext] != null ? map[ext] : map[ext] = {
        files: []
      };
      m.files.push(f);
    }
    for (ext in map) {
      d = map[ext];
      d.summary = helpers.summarize(d.files.map(function(x) {
        return x.stats;
      }));
    }
    return map;
  };

  readSingleFile = function(f) {
    return parseFile(p, function(err, res) {
      addResult(res, result);
      result.summary = res.stats;
      return print(err, result, options, fmtOpts);
    });
  };

  readDir = function(dir) {
    var finish, processFile;
    finish = function(err, x) {
      result.summary = helpers.summarize(result.files.map(function(x) {
        return x.stats;
      }));
      result.byExt = groupByExt(result);
      return print(err, result, options, fmtOpts);
    };
    processFile = function(f, next) {
      return parseFile(f, function(err, r) {
        addResult(r, result);
        return next();
      });
    };
    return readdirp({
      root: dir,
      fileFilter: exts
    }, function(err, res) {
      return async.forEach(filterFiles(res.files), processFile, finish);
    });
  };

  p = programm.args[0];

  fs.lstat(p, function(err, stats) {
    if (err) {
      return console.error("Error: invalid path argument");
    }
    if (stats.isDirectory()) {
      return readDir(p);
    } else if (stats.isFile()) {
      return readSingleFile(p);
    }
  });

}).call(this);
